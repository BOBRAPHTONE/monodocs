# Architectural Overview

This article is a quick tour of the complete framework, its classes and features. We will visit the most important topics and requirements for developing mono applications. The tutorials only shows you how things are done, not why the code is structured the way it is.

#### Who should read this?

If you wish to understand the concept and thoughts behind the frameworks structure. If you should choose to read only one in-depth article, when it should be this one!

## Overview

*Mono Framework* is a collection of C++ classes, all build on top of the [mbed library](http://developer.mbed.org) created by ARM. The complete mono software stack consists of 3 levels of abstractions, which are seperate libraries:

1. **Mono layer** (C++): All highlevel classes
2. **mbed layer** (C++/C): Hardware level I/O and functions (including most of stdlib)
3. **Cypress layer** (C): Hardware dependent code, generated by PSoC Creator

In this article we focus mainly on the *Mono layer*.

## API Overview

Below is a diagram of the features provided by *mono framework*. These are the high-level inetfaces that makes it fast and easy for you to take advantage of all monos features.

![Mono Framework Feature Overview](mono-overview.svg)

As you can see in the diagram, we features can be grouped by their function. Some framework classes are generic, like the mono::String class. Others service a specific purpose, like providing the accelerometer interface.

## Core Concepts

Since there is no operating system, your application will run on *bare metal*, meaning it interfaces the hardware directly. On a versatile platform, such as mono, it means that your application must deal with some critical events and concepts. In the next sections we shall take a look at the key functions and requirements of all applications targeting mono.

### Application lifecycle

The application lifecycle is the time from execution of the first instruction to the last. On convensional environments this is from `main()` gets called, until it returns:

```cpp
	// This is a normal familiar C++ application main function:
	int main(char *argv[], int argc)
	{
		// Application lifecycle begins
		
		// do stuff
		
		// Application lifecycle ends
		return 0;
	}
```

This is the case when you are inside an operating system. Mono is an embedded platform, so here the lifecycle to different and determined by the power *on* and power *off* events.

When the CPU powers up, it will immediately begin executing your application. And it will not stop before you cut the CPU's power source - literally! There is no `return 0` that stops your application.

#### Mono is Always on

Mono's hardware is always powered, there is no power switch. You can not simply cut the power to the CPU when you what to turn off mono. The "turn off" feature needs to be software that throttles down the CPU and puts all periphrals into a low power state. We call this state: ***sleep mode***.

Mono framework helps you with handling *sleep mode*. By default the button on the side of mono will toggle sleep mode. It will put mono to sleep, and wake mono up again if pressed during sleep. You do not need to do anything to support sleep mode, it is provided to you be the framework. Only if you need to make use of the button for you own purpose, you must provide a way of going to sleep. This is done by calling the `IApplicationContext::EnterSleepMode` method:

```cpp
// put mono into sleep mode:
mono::IApplicationContext::EnterSleepMode(); // execution halts here until wake-up

// only after wake-up will EnterSleepMode return
printf("Mono has awaken!");
```

Because power is never cut from the CPU, it rarely resets. The application state is preserev across sleep cycles, meaning that your application lifespan will be long. It might be significantly longer compared to desktop applications. The long lifespan makes the application more vulnerable to errors, such as memory leaks, corrupting memory or stack overflows. The point is: it is a tough job to be an embedded developer :-)

#### Power On Reset

The term *Power On Reset* or POR means the initial reset that occurs when the CPU powers on. This is when the power supply is first asserted or the physical H/W reset line is deasserted. On Mono a POR is the same as a hardware reset.

A POR can be triggered in a number of different ways:

 * Pressing mono reset button
 * If Mono's battery is completely drained, the power control subsystem will cut the CPU supply. When Mono is charged the power to the CPU will be restored and a POR happens.
 * Uploading a new application to Mono, using `monoprog`.

Every mono application is required to handle the POR event. It is here your application must setup all needed periperals, such as temperature sensor or SD Card file I/O. If you use any [UI Widgets](../reference/reference.md), you need to initialize them on POR as well.

Later in the [Required virtual methods](#required-virtual-methods) section, we shall see how you handle the POR event.

#### Sleep and Wake-up

We expect the POR event to be rare, compared the number of sleep and wake up events. When mono goes to sleep it turns off all periphrals to minimize power consumption. The procedure of going to sleep is:

 1. Call your applications default `monoWillGotoSleep()` handler.
 1. Run through all objects that registered themselves as [`IPowerAware`](../references/mono_power_IPowerAware.md), and call their `monoWillGotoSleep()` method.
 1. Tell the Power System IC to turn off peripheral power, which powers off:
 	* Wireless module
 	* SD card
 	* Display
 	* Accelerometer
 	* Temperature sensor
 1. Turn off all on-chip communication interfaces: SPI, I2C, USB etc.
 1. Set all I/O pins to high-impedent inputs, to preserve power
 1. Halt the CPU's instruction fetch (sleep)

* handle when mono goes to sleep
* handle when mono wakes from sleep
* for the lazy: you may just software reset on "wake from sleep"
* as default the user button will sleep/wake mono

### The run loop

* The frameowek abtracts away a lot of periodic tasks and house-keeping.
* like modern GUI systems application handles events
* two application types: event based and real-time

#### Callback functions

* we have callback functions for C++
* beside C function pointers, you can use C++ member pointers (type info is preserved!)

```c++
someObject.setCallback<MyClass>(this, &MyClass::MyHandler);
```

##### Events

* most apps a events based, they change state on events
* events are touch input, power/sleep triggers or button interrupts
* events are handled in callback functions and member method overrides
* a todo list app changes state on touch events, between events it does nothing

##### Timers

* Timers trigger a periodic event handler callback
* Real-Time apps might update its state/content on a regular interval
* Timers can also be used to call a function at some point in the future (as soon as possible).

##### Queued interrupts

* in embedded environment interrupts are hardware triggers, that call a C function (the ISR)
* the ISR should be fast and return very quickly - a lot of concurrency issues arise when using ISR.
* mono uses Queued interrupt, where the ISR is handled in the run loop.
* no concurrency issues
* you can longer lived ISR's
* they can debounce your hardware input signals, to create more robust handling of button or switches

### The Application Controller

All application must have a app controller - this is there entry point

#### Required virtual methods



#### Application Entry Point & Startup

1. static inits
2. main func
3. app ctrl POR method
4. run loop

## The Bootloader

## Crashes and Exceptions

## Best Pratice

some do and dont's

## Further reading

in depth articles:

* Boot and Startup procedures
* Queued callbacks and interrupts
* [[Display System Architecture|display_system_architecture]]
* Touch System Architecture
* Wifi & networking
* Power Management Overview
* Memory Management: Stack vs heap objects?
* Coding C++ for bare metal
* The Build System

